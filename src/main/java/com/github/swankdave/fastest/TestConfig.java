package com.github.swankdave.fastest;

import org.jetbrains.annotations.NotNull;

import java.util.*;

import static com.github.swankdave.fastest.Constants.ARTICLE_NAME;

/**
 * The TestConfig class represents a configuration for a test.
 */
public class TestConfig {

    private final MethodScope methodScope;
    public enum TestSections {
        testDoc,
        preamble,
        testName,
        constructor,
        predicate,
        result,
        error,
        postTest,
    }

    public boolean isException;
    public boolean isInverted;
    public Integer testIndex;
    public boolean containsSet;
    /**
     * Indicates whether the default preamble is being used.
     * <p>
     * The default preamble is constructors for datafragments and the article under test (if the function isn't static).
     * This variable determines whether the default preamble should be used or not.
     */
    public boolean UsingDefaultPreamble = true;

    private final Map<TestSections, List<String>> testPartReferenceMap = new HashMap<>();
    private final Map<TestSections, String> testPartMap = new HashMap<>();

    public String getTestMethodName(){
        return methodScope.getMethodName();
    }
    private String getPrefix() {
        return methodScope.languageConfig.getKeywordPrefixForLanguage();
    }

    public boolean isStatic(){
        return methodScope.getIsStatic();
    }

    public String getPreamble() {
        return testPartMap.get(TestSections.preamble);
    }

    public String getConstructor() {
        return testPartMap.get(TestSections.constructor);
    }

    public String getTestDoc() {
        return testPartMap.get(TestSections.testDoc);
    }

    public String getPredicate() {
        return testPartMap.get(TestSections.predicate);
    }

    public String getResult() {
        return testPartMap.get(TestSections.result);
    }

    public String getError() {
        return testPartMap.get(TestSections.error).trim();
    }

    public String getPostTest() {
        return testPartMap.get(TestSections.postTest);
    }

    public String getTestName() {
        return testPartMap.get(TestSections.testName);
    }

    public void setTestName(String testName) {
        testPartMap.put(TestSections.testName, testName);
    }

    public void setPreamble(String preamble) {
        testPartMap.put(TestSections.preamble, preamble);
    }

    public void setConstructor(String constructor) { testPartMap.put(TestSections.constructor, constructor);}

    public void setPredicate(String predicate) {
        testPartMap.put(TestSections.predicate, predicate);
    }

    public void setResult(String result) {
        testPartMap.put(TestSections.result, result);
    }

    public void setError(String error) {
        testPartMap.put(TestSections.error, error);
    }

    public void setPostTest(String postTest) {
        testPartMap.put(TestSections.postTest, postTest);
    }

    public void setTestDoc(String testDoc) {
        testPartMap.put(TestSections.testDoc, testDoc);
    }

    public TestConfig(MethodScope methodScope) {
        this.methodScope = methodScope;
        this.testIndex = 0;
        setTestDoc("");
        isException = false;
        isInverted = false;
        Arrays.stream(TestSections.values()).forEach(section -> testPartMap.put(section,""));
        Arrays.stream(TestSections.values()).forEach(section -> testPartReferenceMap.put(section, new ArrayList<>()));
    }

    public TestConfig(TestConfig config){
        this(config.methodScope);
        isException = config.isException;
        containsSet = config.containsSet;
        isInverted = config.isInverted;
        UsingDefaultPreamble = config.UsingDefaultPreamble;
        setTestDoc(config.getTestDoc());
        Arrays.stream(TestSections.values()).forEach(section -> testPartMap.put(section, config.testPartMap.get(section)));
        Arrays.stream(TestSections.values()).forEach(section -> testPartReferenceMap.put(section, config.testPartReferenceMap.get(section)));
        //autogenerated pre-amble should be re-autogenerated or not included in new preamble
    }



    /**
     * This method checks if the predicate and result are blank.
     *
     * @return true if both the predicate and result are not blank, false otherwise.
     */
    public boolean isValid() {
        return (!this.getPredicate().isBlank());
    }

    /**
     * Invalidates the test by resetting the predicate, result, test name, and error fields, and setting isException to false.
     */
    public void invalidateTest(){
        setPredicate("");
        setResult("");
        setTestName("");
        setError("");

        isException = false;
    }

    /**
     * Invalidates the post-test by resetting the test name and setting the post-test to an empty string.
     */
    public void invalidatePostTest(){
        invalidateTest();
        setPostTest("");
    }


    /**
     * Invalidates the pre-test by calling invalidatePostTest(), setting the preamble to an empty string, and setting the constructor to an empty string.
     */
    public void invalidatePreTest(){
        invalidatePostTest();
        setPreamble("");
        setConstructor("");
    }

    public boolean containsKeyword(String keyword){
        return containsLiteral(getPrefix() + keyword);
    }

    public boolean containsLiteral(String literal){
        return Arrays.stream(TestSections.values()).anyMatch(section -> testPartMap.get(section).contains(literal));
    }

    /**
     * Expands the test sections in the TestConfig with the specified set literal and replaces them with the given value.
     *
     * @param setLiteral  the set literal to be expanded
     * @param replaceWith the value to replace the set literal with
     */
    public void expandKeyword(String setLiteral, String replaceWith){
        if (replaceWith.trim().split("\\n",2).length == 1)
            replaceWith = replaceWith.trim();
        expandLiteral(getPrefix()+setLiteral, replaceWith);
    }

    /**
     * Expands the test sections in the TestConfig with the specified set literal and replaces them with the given value.
     *
     * @param setLiteral  the set literal to be expanded
     * @param replaceWith the value to replace the set literal with
     */
    public void expandLiteral(String setLiteral, String replaceWith){
        Arrays.stream(TestSections.values()).forEach(section ->{
            if (testPartMap.get(section).contains(setLiteral))
                    testPartReferenceMap.get(section).add(setLiteral);
            testPartMap.put(section, testPartMap.get(section).replace(setLiteral,replaceWith));
        });
    }

    /**
     * Expands the test sections in the TestConfig with the specified set literal and replaces them with the given value.
     *
     * @param name           the name of the section to be expanded
     * @param value          the value to replace the section with
     */
    public void dataExpand(String name, String value) {
        String token = getPrefix() + name;

        if (value.trim().split("\\n",2).length == 1)
            value = value.trim();

        String declaration = Util.getDeclarationFromDefinition(
                name,
                value,
                methodScope.languageConfig);

        if (Arrays.stream(new TestSections[]{
                TestSections.preamble,
                TestSections.constructor,
                TestSections.predicate,
                TestSections.result,
                TestSections.error}).anyMatch(section->testPartMap.get(section).contains(token))){
            addDeclaration(TestSections.preamble, token, declaration);

            Arrays.stream(TestSections.values()).forEach(section->testPartMap.put(section, testPartMap.get(section).replace(token,name)));
        } else if (testPartMap.get(TestSections.postTest).contains(name)) {
            addDeclaration(TestSections.postTest, token, declaration);
            setPostTest(getPostTest().replace(token, value));
            setTestDoc(getTestDoc().replace(token, value));
        }
    }


    /**
     * Adds a declaration to the specified test section in the test configuration.
     *
     * @param testSection  the test section where the declaration will be added
     * @param name         the name of the section to be expanded
     * @param declaration  the declaration to be added
     */
    private void addDeclaration(TestSections testSection, String name, String declaration) {
        String declarationRegex = "\n\\s*" + name + "\\s*(" + methodScope.languageConfig.getLineterminationKeyword() + ")?\\s*\n?";
        if ( testPartMap.get(testSection).matches(declarationRegex))
            testPartMap.put(testSection, testPartMap.get(testSection).replaceAll(declarationRegex,"\n"+ declaration + "\n"));
        else
            testPartMap.put(testSection,  declaration + testPartMap.get(testSection));
    }



    /**
     * Formats the test configuration using the provided language configuration.
     * Sets the test documentation and preamble with the formatted values.
     *
     * @param languageConfig The LanguageConfig object representing the language configuration.
     */
    public void format(LanguageConfig languageConfig) {
        setTestDoc(Util.setMindent(getTestDoc(), languageConfig.getDefaultIndent() ));
        setPreamble(Util.setMindent(getPreamble(), 2*languageConfig.getDefaultIndent()));
    }


    /**
     * Expands the test sections in the TestConfig with the specified set literals and replaces them with the given values.
     *
     * @param classScope  The ClassScope object representing the scope of the class in the test document.
     */
    void expandTestWithFragments(ClassScope classScope) {
        // every expansion introduces the possibility of more references, so whenever we find a keyword,
        // we need to restart our search for keywords in the proper precedent ordering, so we keep expanding
        // references, and starting over in precedence search
        while (true) {
            if (methodScope.getTestFragments().keySet().stream().anyMatch(this::containsKeyword)) {
                methodScope.getTestFragments().forEach(this::expandKeyword);
                continue; //because method fragments can refer to each-other, we need to do this until it has no effect
            }

            if (methodScope.getTestData().keySet().stream().anyMatch(this::containsKeyword)) {
                methodScope.getTestData().forEach(this::dataExpand);
                continue;
            }

            if (classScope.getTestFragments().keySet().stream().anyMatch(this::containsKeyword)) {
                classScope.getTestFragments().forEach(this::expandKeyword);
                continue;
            }

            if (classScope.getTestData().keySet().stream().anyMatch(this::containsKeyword)) {
                classScope.getTestData().forEach(this::dataExpand);
                continue;
            }
            break;
        }
    }

    /**
     * Expands the test sections in the TestConfig with the specified set literals and replaces them with the given values.
     *
     * @param setGroup The set group containing the set literals and their corresponding values.
     * @return The expanded list of TestConfig objects.
     */
    @NotNull List<TestConfig> expandTestWithSets(Map<String, List<String>> setGroup) {
        var rtn = new LinkedList<TestConfig>();
        //get the list of sets (under the current set identifier) that exist in the current test,
        // by looking for each litteral definition of that set
        //set litteral: (1,2,3)SETA
        var setLiterals = (setGroup.keySet().stream().filter(this::containsLiteral)).toList();
        //if we found any full text set definitions
        if (!setLiterals.isEmpty()) {
            //for each member of the first set for this set litteral
            //for set litteral (1,2,3)SETA, the members are 1, 2 and 3, which will be substituted, in the text, for (1,2,3)SETA
            for (int i = 0; i < setGroup.get(setLiterals.get(0)).size(); i++) {
                //copy the current test
                var newTest = new TestConfig(this);
                //java doesn't like handing iteration variables directly to lambda's for some reason
                int finalI = i;
                //replace full text definition of all set literals with the fully expanded set value corresponding to the current set item index
                setLiterals.forEach(literal -> newTest.expandLiteral(literal, setGroup.get(literal).get(finalI)));
                //add new test to list of tests to be returned and flattened by flatmap
                rtn.add(newTest);
            }
        } else
            //this test does not need set expansion
            rtn.add(this);
        return rtn;
    }

    /**
     * Sets the default preamble for the configuration. It sets the flag UsingDefaultPreamble to true and
     * updates the preamble of the config by generating it based on the given ARTICLE_NAME, classScope,
     * and languageConfig. The preamble is generated by calling Util.getDeclarationFromDefinition
     * method with the appropriate parameters.
     *
     * @param classScope
     */
    void applyDefaultPreamble(ClassScope classScope) {
        UsingDefaultPreamble = true;
        setPreamble(Util.getDeclarationFromDefinition(
                ARTICLE_NAME,
                classScope.languageConfig.getNewValueKeyword()+ " " +
                        classScope.getClassName().trim() + (getConstructor().isBlank() ? "()" : getConstructor()), classScope.languageConfig));
    }
}
